

Your application's `Dockerfile` needs to be modified to include the wait script and a new entrypoint script (`start.sh`).

```dockerfile
# --- In the final stage of your Dockerfile ---

WORKDIR /app

# Copy wait script and make it executable
COPY wait-for.sh .
RUN chmod +x wait-for.sh

# Copy the startup script
COPY start.sh .

# Copy migration files
COPY db/migration ./migration

# Copy the application binary
COPY --from=builder /app/main .

# Expose the application port
EXPOSE 8080

# Set the entrypoint to our startup script
ENTRYPOINT [ "/app/start.sh" ]

# Provide the default command for the entrypoint
CMD [ "/app/main" ]
```

#### Step 2: Create the `start.sh` Script

This script will run the database migrations and then execute the main application binary. The `exec "$@"` part is important; it replaces the script process with the command passed as arguments (in our case, `/app/main` from the `CMD` instruction).

```sh
#!/bin/sh

# Exit immediately if a command exits with a non-zero status.
set -e

# Run database migrations
/app/migrate -path /app/migration -database "$DB_SOURCE" -verbose up

# Execute the command passed to the script
echo "Starting the application..."
exec "$@"
```

#### Step 3: Update `docker-compose.yaml` to Use the Wait Script

Finally, we override the `entrypoint` in our `docker-compose.yaml` to orchestrate the waiting.

```yaml
version: "3.9"
services:
  postgres:
    # ... (same as before)

  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - DB_SOURCE=postgresql://root:secret@postgres:5432/simple_bank?sslmode=disable
    depends_on:
      - postgres
    entrypoint: [ "/app/wait-for.sh", "postgres:5432", "--", "/app/start.sh" ]
    command: [ "/app/main" ]
```

### Entrypoint and Command Explained:

1.  **`depends_on`**: We still include this for clarity and to ensure the container start order is correct.
2.  **`entrypoint`**: This overrides the `ENTRYPOINT` in the `Dockerfile`.
    *   `/app/wait-for.sh`: The script to run.
    *   `postgres:5432`: The host and port it should wait for.
    *   `--`: A separator that tells `wait-for.sh` that the subsequent arguments are the command to execute after the wait is over.
    *   `/app/start.sh`: The script to run once `postgres:5432` is accessible.
3.  **`command`**: When you override the `entrypoint` in `docker-compose.yaml`, the `CMD` from the `Dockerfile` is ignored. You must provide the `command` here explicitly. This command (`/app/main`) is passed as an argument to the entrypoint script (`start.sh`).

## 5. Running the Application

With the files in place, you can now manage your application with these commands:

*   **Start the services:**
    ```sh
    docker compose up
    ```
    (Add `-d` to run in detached mode).

*   **Stop and remove containers, networks, and volumes:**
    ```sh
    docker compose down
    ```

*   **Force a rebuild of the images before starting:**
    ```sh
    docker compose up --build
    ```

Now, when you run `docker compose up`, the `api` service will wait for the `postgres` service to be ready, then run migrations, and finally start the application server, preventing any race conditions.



