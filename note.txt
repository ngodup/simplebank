This document summarizes a lecture on implementing authentication and authorization for a backend API using Go and the Gin framework.

### Core Problem
The initial API was insecure, allowing unauthorized access to all endpoints. For example, any user could view all bank accounts or transfer money from any account without proper verification.

### Objective
The goal was to secure the API by implementing a bearer token-based authorization system. Protected endpoints should only be accessible with a valid access token, and users should only be able to access or modify resources they own.

### Authentication Middleware (`api/middleware.go`)
A Gin middleware was created to handle authentication.

**Workflow:**
1.  The middleware is a higher-order function (`authMiddleware`) that takes a `token.Maker` interface and returns a `gin.HandlerFunc`.
2.  It extracts the `Authorization` header from incoming requests.
3.  It validates the header, expecting the format: `Bearer <access_token>`.
4.  If the header or token is missing, malformed, or invalid (e.g., expired), the middleware aborts the request with a `401 Unauthorized` error.
5.  If the token is valid, its payload (containing user information) is extracted and stored in the Gin context for later use by the API handler.
6.  The request is then forwarded to the actual API handler using `ctx.Next()`.

### Middleware Integration (`api/server.go`)
- A new route group was created for all routes that require authentication using `router.Group("/")`.
- The `authMiddleware` was applied to this group, ensuring that every request to a route within this group first passes through the authentication check.
- Public routes like user creation and login were excluded from this group.

Now all testcase to previous route are failed liek TestGetAccountAPI because the API is now return 401 instead of 200 to fixed this 
we need to add authorization header to the request. Before doing that we need to verify who this token is belong to particular user, 
as auth middleware does only authenticating request that is to verify if client provide access token. The important part the authorization part 
is missing at this point.

### Implementing Authorization Logic (In API Handlers)
While the middleware handles **authentication** (verifying the user's identity), **authorization** (checking user permissions) is implemented within each API handler.

1.  **Retrieve User:** Handlers access the authenticated user's data from the Gin context via `ctx.MustGet(authorizationPayloadKey)`.
2.  **Implement Rules:**
    *   **Create Account:** The account `owner` is automatically set to the authenticated user's username.
    *   **Get/List Accounts:** The API now checks if the requested account's owner matches the authenticated user. The SQL query for listing accounts was updated to filter by the `owner`.
    *   **Transfer Money:** The API verifies that the `from_account` in a transfer request belongs to the authenticated user, preventing them from spending other users' money.
In GetList account we need to modify account.sql to get list of account only belong to user, modify -- name: ListAccounts :many and after that 
run make sqlc and make mock

### Testing
- **Middleware Tests (`api/middleware_test.go`):** Unit tests were written for the middleware using a table-driven approach to cover various scenarios, including valid tokens, missing headers, unsupported authorization types, and expired tokens.
- **API Handler Tests:** Existing unit tests for the API handlers were updated to include a valid `Authorization` header in requests and to assert the new authorization logic.

### Conclusion
The implementation successfully secured the API by adding a robust authentication middleware and API-specific authorization rules, ensuring that users can only perform actions and access data for which they have permission.