How to deploy an application ?
Fist step :  Dockerizing a Go application as a preliminary step for deployment to AWS.

Key technical points and procedures covered:

1.  **Git Workflow:**
    *   Emphasizes the best practice of not pushing directly to the `main` branch.
    *   Demonstrates creating a new feature branch: `git checkout -b ft/docker`. where ft : stand for feature
    *   Changes are committed to the feature branch and a Pull Request is created on GitHub for review and CI checks.
    * Only merge it back after the nex code is properly tested and reviewed.

2.  **Environment Updates:**
    If youer go version is old then let update our project to make sure it is compatible with this new version. 
    *   Change if need in go.mod The Go version is updated to `1.24.5` in `go.mod` and also update the `.github/workflows/ci.yml` file.
    *   Check git status in terminal, we see to uncommited, let add, commit and push the code , we need to push to
     >git push origin ft/docker 
    `golang-migrate` is upgraded to the latest version (`4.14.1`) using `brew upgrade golang-migrate`.

3.  **Dockerfile Creation (Multi-Stage Build):**
    *   The primary goal is to create a minimal, lightweight Docker image for production.
    *   **Stage 1 (Builder):**
        *   `FROM golang:1.24.5-alpine AS builder`
        *   The Go source code is copied into the container.
        *   The application is compiled into a single binary: `RUN go build -o main main.go`.
    *   **Stage 2 (Final Image):**
        *   `FROM alpine:3.19` (a very small base image).
        *   The compiled binary from the `builder` stage is copied over: `COPY --from=builder /app/main .`.
        *   The application port is documented: `EXPOSE 8080`.
        *   The default command to run the application is set: `CMD ["/app/main"]`.

4.  **Results:**
    *   A single-stage build resulted in a large image (452 MB).
    *   The multi-stage build produced a significantly smaller, optimized image (17.7 MB).

5.  **Docker Commands:**
    *   Build command: `docker build -t simplebank:latest .`
    *   List images: `docker images`

The next step mentioned is to run the application using the newly created Docker image and connect it to a Postgres container.
