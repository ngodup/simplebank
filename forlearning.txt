
Lecture Video 15 : Mock DB for testing HTTP API
-----------------------------------------------
## Mock Testing Explained we have done in api/accout_test.go 

### What is Mock Testing?

Mock testing is a technique used in unit testing. It involves creating "mock" or "fake" objects that simulate the behavior of real, complex dependencies. In this project, `account_test.go` uses mock testing to test the API handlers in `account.go`.

Instead of interacting with a real database, the tests use a **mock `Store`**. This mock `Store` is a simulated object that we can program to behave in specific ways for each test case. For example, we can tell the mock to:

1.  Return a specific account when `GetAccount` is called.
2.  Return a `sql.ErrNoRows` error to simulate a "not found" scenario.
3.  Return any other type of error to test the API's error handling.

This is done using `go.uber.org/mock/mockgen`, which automatically generates the necessary mock code from the `db.Store` interface.

### Is Mock Testing Used in Production Projects?

**Yes, absolutely.** Mocking is a standard and essential practice in professional software development for several key reasons:

1.  **Isolation**: It allows you to test a single unit of code (like an API handler) in complete isolation. If a test fails, you know the bug is in the code you are testing, not in its dependencies (like the database).
2.  **Speed**: Mock tests are extremely fast because they don't involve slow operations like network calls or database connections. This allows developers to run hundreds or thousands of tests in seconds, providing rapid feedback.
3.  **Control & Predictability**: Mocks give you full control over the test environment. You can easily simulate edge cases and error conditions (e.g., database connection failure, disk full) that are often very difficult to reproduce with real systems.
4.  **Development in Parallel**: Frontend and backend teams can work independently. A frontend team can test its code against a mock API server before the real backend is even built.

While mock testing is crucial for *unit tests*, a comprehensive testing strategy also includes *integration tests*, where the API is tested with a real, running database to ensure all the parts of the system work together correctly.

----************************************************************************---

Lecture video 16 : Implement Transfer money api with a custom validator
----------------------------------------------------------------------

## Session Notes: Money Transfer API & Custom Validation

This session focused on implementing the core money transfer API and improving data validation within the application.

### 1. Money Transfer API Endpoint

- **New Feature**: Created a new API endpoint `POST /transfers` to handle money transfer requests.
- **Implementation**: The `createTransfer` function in `api/transfer.go` contains the logic for processing transfers.

### 2. Custom Validation for Currencies

To make the system more robust and scalable, we moved from a hardcoded list of currencies to a custom validation rule.

- **Problem**: The currency validation was previously defined directly in the model struct (`binding:"required,oneof=USD EUR"`). This is not ideal because:
    - It's not easily reusable across different structs.
    - Adding new currencies requires changing struct tags in multiple places.

- **Solution**: A custom validator was implemented.
    1.  **`validator.go`**: A new `validCurrency` function was created to check if a given currency is supported.
    2.  **`server.go`**: This new validator was registered with Gin's validator engine at startup, linking it to the custom tag `currency`.
    3.  **`account.go`**: The `createAccountRequest` struct was updated to use the new custom rule: `binding:"required,currency"`.

- **Benefit**: This change centralizes the currency validation logic, making it easier to maintain and update. We can now reuse the `currency`
----************************************************************************---

Lesson Video 17 : Add users table with unique & foreign key contstrants
-----------------------------------------------------------------------

## Session Notes: Adding Users table and Refining Database Schema

This session was a major step in the project's development. We introduced a `users` table, established a proper relationship between users and their accounts, and improved the `Makefile` for more controlled database migrations.

### 1. Creating the `users` Table

We created a new migration file (`000002_add_users.up.sql`) to define the schema for our `users` table.

**What:** The `users` table was created with the following columns:

- `username`: A unique primary key to identify each user.
- `hashed_password`: To securely store user passwords.
- `full_name`: The user's full name.
- `email`: A unique email address for each user.
- `password_change_at`: To track when the password was last changed (important for security).
- `created_at`: A timestamp to record when the user account was created.

**Why:** This is a fundamental step towards building a real application. By creating a `users` table, we can now properly associate accounts with specific users, which is essential for implementing authentication and authorization.

### 2. Linking Users and Accounts with Constraints

After creating the `users` table, we established a formal link between it and the existing `accounts` table.

**What & How:**

1.  **Foreign Key:** We added a foreign key constraint to the `accounts` table. This constraint ensures that every `owner` value in the `accounts` table *must* correspond to a valid `username` in the `users` table.

    ```sql
    ALTER TABLE "accounts" ADD FOREIGN KEY ("owner") REFERENCES "users" ("username");
    ```

2.  **Unique Constraint:** We added a unique constraint to the `accounts` table to prevent a single user from having multiple accounts with the same currency.

    ```sql
    ALTER TABLE "accounts" ADD CONSTRAINT "owner_currency_key" UNIQUE ("owner", "currency");
    ```

**Why:**

- The **foreign key** enforces data integrity. It makes it impossible to have an account without a valid owner, which prevents orphaned data and ensures the database remains consistent.
- The **unique constraint** is a business rule that prevents duplicate accounts for the same user and currency, which is a common requirement in banking applications.

### 3. Improving the `Makefile`

To make working with these migrations easier and safer, we added two new commands to the `Makefile`:

- `migrateup1`: Applies a single "up" migration.
- `migratedown1`: Reverts a single "down" migration.

**Why:** These commands give us the precision to test and debug each migration file individually, which is much safer than applying or reverting all migrations at once.

----************************************************************************---

Lesson Video 18 : How to handle DB errors in Golang Correctly
-----------------------------------------------------------------------

What we did:
- Implemented user creation and retrieval functionality.
- Added password hashing and verification using bcrypt.
- Updated the accounts API to handle potential database constraint violations (foreign key, unique).
- Added comprehensive tests for the new user functionality and the accounts API.

What we learned:
- How to add a new database table and generate corresponding Go code with sqlc.
- How to implement user authentication features, including password hashing with bcrypt.
- How to handle specific database errors in the API layer to provide more meaningful error messages to the client.
- The importance of testing new functionality thoroughly, including unit tests for database queries and API endpoints.

______________________*****************************__________________________________

Lesson Video 19 :  ### Tutorial: Secure User Registration with Password Hashing
-----------------------------------------------------------------------

This tutorial outlines the steps to implement a secure user registration system with password hashing using bcrypt.
Step 1. Implement Password Hashing Utilities (`util/password.go`)**

- **`HashPassword(password string)`**: Takes a plain-text password and returns a bcrypt hash. This function uses `bcrypt.GenerateFromPassword` with a default cost to create a secure hash. It's crucial to never store plain-text passwords.
- **`CheckPassword(password, hashedPassword string)`**: Compares a plain-text password with a stored hash to verify a user's credentials. It uses `bcrypt.CompareHashAndPassword`.

Step 2. Test Hashing Functions (`util/password_test.go`)**

- The main objective is to verify that `HashPassword` and `CheckPassword` work correctly. 
- Tests ensure that:
    - A correct password passes the check.
    - An incorrect password fails the check.
    - Hashing the same password twice produces two different hashes due to the random salt generated by bcrypt, which protects against rainbow table attacks.

Step 3. Update User Tests (`db/sqlc/user_test.go`)**

- Modify the `createRandomUser` test helper to use the new `util.HashPassword` function. This ensures that tests use realistic, hashed passwords, making them more robust.

Step 4. Create the User Registration API Endpoint (`api/user.go`)**

- **Define `createUserRequest` struct**: This struct defines the expected input for the user registration endpoint, with validation tags for each field (e.g., `required`, `alphanum`, `min=6`, `email`).
- **Implement `createUser` handler**:
    - It binds and validates the incoming JSON request.
    - It calls `util.HashPassword` to hash the user's password.
    - It calls `store.CreateUser` to save the new user to the database.
    - It includes error handling to catch duplicate usernames or emails, returning a `StatusForbidden` (403) error.

Step 5. Register the API Route (`api/server.go`)**
 - Add a new `POST /users` route to the router to make the `createUser` handler accessible.

Step 6. Secure the API Response (`api/user.go`)**

- **Create `createUserResponse` struct**: This new struct is a subset of the `db.User` model, excluding the `HashedPassword`.
- **Modify `createUser` handler**: Instead of returning the full `db.User` object, the handler now populates and returns the `createUserResponse` struct. This prevents the hashed password from being exposed to the client, which is a critical security best practice.

Step 7. Manual Testing (Postman)**

- Use a tool like Postman to test the `POST /users` endpoint with various scenarios:
    - Successful user creation.
    - Attempts to create users with duplicate usernames or emails.
    - Requests with invalid data (e.g., short passwords, invalid email formats) to ensure validation is working correctly.

____________________________________________*****************************__________________________________

Lesson Video 18 : 
-----------------------------------------------------------------------

Lesson Video 18 : 
-----------------------------------------------------------------------