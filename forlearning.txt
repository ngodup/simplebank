
Lecture Video 15 : Mock DB for testing HTTP API
-----------------------------------------------
## Mock Testing Explained we have done in api/accout_test.go 

### What is Mock Testing?

Mock testing is a technique used in unit testing. It involves creating "mock" or "fake" objects that simulate the behavior of real, complex dependencies. In this project, `account_test.go` uses mock testing to test the API handlers in `account.go`.

Instead of interacting with a real database, the tests use a **mock `Store`**. This mock `Store` is a simulated object that we can program to behave in specific ways for each test case. For example, we can tell the mock to:

1.  Return a specific account when `GetAccount` is called.
2.  Return a `sql.ErrNoRows` error to simulate a "not found" scenario.
3.  Return any other type of error to test the API's error handling.

This is done using `go.uber.org/mock/mockgen`, which automatically generates the necessary mock code from the `db.Store` interface.

### Is Mock Testing Used in Production Projects?

**Yes, absolutely.** Mocking is a standard and essential practice in professional software development for several key reasons:

1.  **Isolation**: It allows you to test a single unit of code (like an API handler) in complete isolation. If a test fails, you know the bug is in the code you are testing, not in its dependencies (like the database).
2.  **Speed**: Mock tests are extremely fast because they don't involve slow operations like network calls or database connections. This allows developers to run hundreds or thousands of tests in seconds, providing rapid feedback.
3.  **Control & Predictability**: Mocks give you full control over the test environment. You can easily simulate edge cases and error conditions (e.g., database connection failure, disk full) that are often very difficult to reproduce with real systems.
4.  **Development in Parallel**: Frontend and backend teams can work independently. A frontend team can test its code against a mock API server before the real backend is even built.

While mock testing is crucial for *unit tests*, a comprehensive testing strategy also includes *integration tests*, where the API is tested with a real, running database to ensure all the parts of the system work together correctly.

----************************************************************************---

Lecture video 16 : Implement Transfer money api with a custom validator
----------------------------------------------------------------------

## Session Notes: Money Transfer API & Custom Validation

This session focused on implementing the core money transfer API and improving data validation within the application.

### 1. Money Transfer API Endpoint

- **New Feature**: Created a new API endpoint `POST /transfers` to handle money transfer requests.
- **Implementation**: The `createTransfer` function in `api/transfer.go` contains the logic for processing transfers.

### 2. Custom Validation for Currencies

To make the system more robust and scalable, we moved from a hardcoded list of currencies to a custom validation rule.

- **Problem**: The currency validation was previously defined directly in the model struct (`binding:"required,oneof=USD EUR"`). This is not ideal because:
    - It's not easily reusable across different structs.
    - Adding new currencies requires changing struct tags in multiple places.

- **Solution**: A custom validator was implemented.
    1.  **`validator.go`**: A new `validCurrency` function was created to check if a given currency is supported.
    2.  **`server.go`**: This new validator was registered with Gin's validator engine at startup, linking it to the custom tag `currency`.
    3.  **`account.go`**: The `createAccountRequest` struct was updated to use the new custom rule: `binding:"required,currency"`.

- **Benefit**: This change centralizes the currency validation logic, making it easier to maintain and update. We can now reuse the `currency`
----************************************************************************---

Lesson Video 17 : Add users table with unique & foreign key contstrants
-----------------------------------------------------------------------

## Session Notes: Adding Users table and Refining Database Schema

This session was a major step in the project's development. We introduced a `users` table, established a proper relationship between users and their accounts, and improved the `Makefile` for more controlled database migrations.

### 1. Creating the `users` Table

We created a new migration file (`000002_add_users.up.sql`) to define the schema for our `users` table.

**What:** The `users` table was created with the following columns:

- `username`: A unique primary key to identify each user.
- `hashed_password`: To securely store user passwords.
- `full_name`: The user's full name.
- `email`: A unique email address for each user.
- `password_change_at`: To track when the password was last changed (important for security).
- `created_at`: A timestamp to record when the user account was created.

**Why:** This is a fundamental step towards building a real application. By creating a `users` table, we can now properly associate accounts with specific users, which is essential for implementing authentication and authorization.

### 2. Linking Users and Accounts with Constraints

After creating the `users` table, we established a formal link between it and the existing `accounts` table.

**What & How:**

1.  **Foreign Key:** We added a foreign key constraint to the `accounts` table. This constraint ensures that every `owner` value in the `accounts` table *must* correspond to a valid `username` in the `users` table.

    ```sql
    ALTER TABLE "accounts" ADD FOREIGN KEY ("owner") REFERENCES "users" ("username");
    ```

2.  **Unique Constraint:** We added a unique constraint to the `accounts` table to prevent a single user from having multiple accounts with the same currency.

    ```sql
    ALTER TABLE "accounts" ADD CONSTRAINT "owner_currency_key" UNIQUE ("owner", "currency");
    ```

**Why:**

- The **foreign key** enforces data integrity. It makes it impossible to have an account without a valid owner, which prevents orphaned data and ensures the database remains consistent.
- The **unique constraint** is a business rule that prevents duplicate accounts for the same user and currency, which is a common requirement in banking applications.

### 3. Improving the `Makefile`

To make working with these migrations easier and safer, we added two new commands to the `Makefile`:

- `migrateup1`: Applies a single "up" migration.
- `migratedown1`: Reverts a single "down" migration.

**Why:** These commands give us the precision to test and debug each migration file individually, which is much safer than applying or reverting all migrations at once.

----************************************************************************---

Lesson Video 18 : How to handle DB errors in Golang Correctly
-----------------------------------------------------------------------

What we did:
- Implemented user creation and retrieval functionality.
- Added password hashing and verification using bcrypt.
- Updated the accounts API to handle potential database constraint violations (foreign key, unique).
- Added comprehensive tests for the new user functionality and the accounts API.

What we learned:
- How to add a new database table and generate corresponding Go code with sqlc.
- How to implement user authentication features, including password hashing with bcrypt.
- How to handle specific database errors in the API layer to provide more meaningful error messages to the client.
- The importance of testing new functionality thoroughly, including unit tests for database queries and API endpoints.

______________________*****************************__________________________________

Lesson Video 19 :  ### Tutorial: Secure User Registration with Password Hashing
-----------------------------------------------------------------------

This tutorial outlines the steps to implement a secure user registration system with password hashing using bcrypt.
Step 1. Implement Password Hashing Utilities (`util/password.go`)**

- **`HashPassword(password string)`**: Takes a plain-text password and returns a bcrypt hash. This function uses `bcrypt.GenerateFromPassword` with a default cost to create a secure hash. It's crucial to never store plain-text passwords.
- **`CheckPassword(password, hashedPassword string)`**: Compares a plain-text password with a stored hash to verify a user's credentials. It uses `bcrypt.CompareHashAndPassword`.

Step 2. Test Hashing Functions (`util/password_test.go`)**

- The main objective is to verify that `HashPassword` and `CheckPassword` work correctly. 
- Tests ensure that:
    - A correct password passes the check.
    - An incorrect password fails the check.
    - Hashing the same password twice produces two different hashes due to the random salt generated by bcrypt, which protects against rainbow table attacks.

Step 3. Update User Tests (`db/sqlc/user_test.go`)**

- Modify the `createRandomUser` test helper to use the new `util.HashPassword` function. This ensures that tests use realistic, hashed passwords, making them more robust.

Step 4. Create the User Registration API Endpoint (`api/user.go`)**

- **Define `createUserRequest` struct**: This struct defines the expected input for the user registration endpoint, with validation tags for each field (e.g., `required`, `alphanum`, `min=6`, `email`).
- **Implement `createUser` handler**:
    - It binds and validates the incoming JSON request.
    - It calls `util.HashPassword` to hash the user's password.
    - It calls `store.CreateUser` to save the new user to the database.
    - It includes error handling to catch duplicate usernames or emails, returning a `StatusForbidden` (403) error.

Step 5. Register the API Route (`api/server.go`)**
 - Add a new `POST /users` route to the router to make the `createUser` handler accessible.

Step 6. Secure the API Response (`api/user.go`)**

- **Create `createUserResponse` struct**: This new struct is a subset of the `db.User` model, excluding the `HashedPassword`.
- **Modify `createUser` handler**: Instead of returning the full `db.User` object, the handler now populates and returns the `createUserResponse` struct. This prevents the hashed password from being exposed to the client, which is a critical security best practice.

Step 7. Manual Testing (Postman)**

- Use a tool like Postman to test the `POST /users` endpoint with various scenarios:
    - Successful user creation.
    - Attempts to create users with duplicate usernames or emails.
    - Requests with invalid data (e.g., short passwords, invalid email formats) to ensure validation is working correctly.

____________________________________________*****************************__________________________________

Lesson Video 20 : 20. How to write stronger unit tests with a custom gomock matcher
-----------------------------------------------------------------------
### Tutorial: Unit Testing with Custom Gomock Matchers for Hashed Passwords

### Advanced Unit Testing: Why and How to Build Custom Gomock Matchers in Go

This tutorial explores a common challenge in unit testing—verifying arguments that are dynamically generated or transformed—and provides a powerful solution using custom `gomock` matchers.

**1. The Goal: Writing Tests We Can Trust**

Our goal is to write a unit test for our `createUser` API. A good test should fail if the implementation is wrong and pass if it's correct. However, standard testing tools sometimes fall short.

**2. The Limitations of Standard Matchers**

When testing our user create API, we need to mock the `store.CreateUser` database call. The challenge lies in verifying the `params` argument passed to it.

**Scenario A: The `gomock.Any()` Trap**

Initially, we might use `gomock.Any()`: in user_test.go for createUser case ok

```go
store.EXPECT().CreateUser(gomock.Any(), gomock.Any())
```

This is too weak and can hide critical bugs:

- **Issue #1 (The Empty User Bug)**: If a developer mistakenly adds `arg = db.CreateUserParams{}` in api/user.go in the handler, 
the API would create an empty user in the database. The test with `gomock.Any()` would still **pass**, failing to catch this major bug.
- **Issue #2 (The Constant Password Bug)**: If the handler was incorrectly hardcoded to use a constant password (`util.HashPassword("some-string")`) instead of the user's input, `gomock.Any()` would also allow the test to **pass**, completely missing the security flaw.

**Scenario B: The `gomock.Eq()` Dead End**

The next logical step is to use `gomock.Eq()` for a precise match. However, this approach also fails, but for a different reason.

```go
// In the test:
hashedPassword, _ := util.HashPassword(password)
arg := db.CreateUserParams{ HashedPassword: hashedPassword, ... }
store.EXPECT().CreateUser(gomock.Any(), gomock.Eq(arg))
```

This test will **always fail**. The `bcrypt` algorithm uses a random salt, meaning `util.HashPassword()` produces a *different* hash every time, even with the same input. 
The hash generated in the test will never equal the one generated in the API handler.

**3. When Are Custom Matchers Needed? (Generalizing the Problem)**

This isn't just about passwords. A custom matcher is the right tool whenever you need to test a function argument that is:

-   **Non-Deterministic**: Like a hashed password, where the output changes on every call.
-   **Dynamically Generated**: Such as a struct field that gets a new `UUID` or a `CreatedAt`/`UpdatedAt` timestamp assigned inside the function you're testing.
-   **Requires Complex Validation**: When simple equality isn't enough, and you need to run custom logic to verify an argument's correctness.

**4. The Solution: Crafting a Custom Matcher**

We solve this by creating a matcher that understands our specific requirements.

- **Step 1: Define the Matcher Struct**
  It holds the expected argument and the original plain-text password needed for verification.
  ```go
  type eqCreateUserParamsMatcher struct {
      arg      db.CreateUserParams
      password string
  }
  ```

- **Step 2: Implement the `Matches()` Method**
  This is the core logic where we compare the actual argument (`x`) with our expectations.
  ```go
  func (e eqCreateUserParamsMatcher) Matches(x interface{}) bool {
      arg, ok := x.(db.CreateUserParams)
      if !ok { return false } // Type assertion failed

      // 1. Custom Logic: Check the password first.
      err := util.CheckPassword(e.password, arg.HashedPassword)
      if err != nil { return false } // Passwords don't match

      // 2. Prepare for DeepEqual: Since the hash is valid, we copy it to our expected arg.
      e.arg.HashedPassword = arg.HashedPassword

      // 3. Standard Logic: Compare the rest of the fields.
      return reflect.DeepEqual(e.arg, arg)
  }
  ```

- **Step 3: Implement the `String()` Method**
  This provides a clear error message if the test fails.

- **Step 4: Create a Helper Function**
  This makes the matcher easy and clean to use in our tests.
  ```go
  func EqCreateUserParams(arg db.CreateUserParams, password string) gomock.Matcher {
      return eqCreateUserParamsMatcher{arg, password}
  }
  ```

**5. The Final, Robust Test**

Now, our test is both strong and precise. It correctly verifies the behavior of our API without being brittle.

```go
store.EXPECT().
    CreateUser(gomock.Any(), EqCreateUserParams(arg, password)).
    Times(1).
    Return(user, nil)
```

This test will now correctly fail if the handler creates an empty user or uses the wrong password, and it will pass when the implementation
 is correct. By building a custom matcher, we have created a truly reliable unit test.


____________________________________________*****************************__________________________________



Lesson Video 21 : 21. Why PASETO is better than JWT for token-based authentication?
-----------------------------------------------------------------------
### Summary of Token-Based Authentication: JWT vs. PASETO

This document summarizes the key concepts of token-based authentication, focusing on the differences, vulnerabilities, and 
security models of JSON Web Tokens (JWT) and Platform-Agnostic Security Tokens (PASETO).

---

### 1. Token-Based Authentication Flow

1.  **Login:** The client sends credentials (e.g., username/password) to the server.
2.  **Token Generation:** The server validates the credentials, creates a signed access token, and sends it back to the client.
3.  **Authenticated Requests:** The client includes the access token in the authorization header of subsequent requests to access protected resources.
4.  **Verification:** The server verifies the token's signature and validity for each request before authorizing it. The token is typically valid for a limited time.

---

### 2. JSON Web Token (JWT)

JWT is a widely used standard for creating access tokens. It hase two types symmetric and asymmetric.

**Structure:** A JWT consists of three Base64-encoded parts separated by dots: `header.payload.signature`.
*   **Header:** Contains metadata, including the token type (`JWT`) and the signing algorithm (`alg`), e.g., `HS256` or `RS256`.
*   **Payload:** Contains claims, which are statements about an entity (typically the user) and additional data like expiration time (`exp`). **The payload is only encoded, not encrypted, and is publicly readable.**
*   **Signature:** Used to verify the integrity of the token. It is created by signing the header and payload with a secret (for symmetric algorithms) or a private key (for asymmetric algorithms).

**Key Security Context (Vulnerabilities):**
*   **Algorithm Flexibility is a Weakness:** JWT allows developers to choose from many signing algorithms, including some known to be weak (e.g., RSA with PKCSv1.5 is susceptible to padding oracle attacks).
*   **`alg: "none"` in header. Attack:** A critical historical vulnerability where an attacker could set the algorithm in the header to `"none"`, causing some libraries to bypass signature verification entirely.
*   **Algorithm Confusion Attack (Key Confusion):** This is a more dangerous attack. If a server uses an asymmetric algorithm (e.g., RS256) where the public key is known, an attacker can:
    1.  Forge a token with a malicious payload.
    2.  Change the `alg` in the header to a symmetric one, like `HS256`.
    3.  Sign the token using the server's **public key** as the secret.
    4.  The server, seeing `alg: "HS256"`, treats the public key as the symmetric secret and successfully validates the token, granting the attacker access.
*   **Mitigation:** A critical server-side check is required to ensure the `alg` from the token header matches the expected algorithm before verification.

---

### 3. PASETO (Platform-Agnostic Security Token)

PASETO was designed as a secure-by-default alternative to JWT, fixing its fundamental design flaws.

**Core Principles:**
*   **No Algorithm Choice:** PASETO uses fixed, strong cryptographic suites based on its version. Developers do not choose the algorithm, eliminating the risk of selecting a weak one.
*   **No Algorithm in Header:** The token's structure itself defines the cryptographic operations, making algorithm confusion attacks impossible.
*   **Authenticated Encryption:** All parts of the token are authenticated, preventing tampering.

**Structure:** `version.purpose.payload(.footer)`
*   **Version:** Specifies the PASETO version (e.g., `v2`).
*   **Purpose:** Defines the use case and the cryptography applied:
    *   `local`: For internal services. Uses a symmetric key. **The payload is encrypted (AEAD), not just encoded.**
    *   `public`: For external services. Uses an asymmetric key pair. The payload is encoded and digitally signed.
*   **Payload:** The main content. It is either encrypted (`local`) or signed (`public`).
*   **Footer (Optional):** Public, unencrypted, but authenticated metadata.

**Key Security Context (Improvements over JWT):**
*   **Secure by Default:** Eliminates JWT's most critical vulnerabilities by design.
*   **Strong Cryptography:**
    *   **Version 2 (Modern):**
        *   `local`: XChaCha20-Poly1305 (AEAD).
        *   `public`: Ed25519 (Edwards-curve Digital Signature Algorithm).
*   **Forgery is Not Trivial:** Because the algorithm is not specified in a header and all parts are authenticated, it is not possible to tamper with the token's contents or intended cryptographic operations.
*   **Confidentiality for `local` tokens:** The payload is encrypted, protecting its contents from being read by unauthorized parties.

____________________________________________*****************************__________________________________

Lesson Video 22 : Tutorial: Implementing Secure Token-Based Authentication in Go (JWT & PASETO)
-----------------------------------------------------------------------
Hello everyone! In this tutorial, we'll build a robust token-based authentication system in Go. We'll explore how to implement both JSON Web Tokens (JWT) and PASETO, highlighting the key differences and demonstrating why PASETO is often the more secure and simpler choice.

### Step 1: Define a Generic Token `Maker` Interface

First, we'll define a generic interface for our token makers. This is a crucial design step that allows us to easily switch between JWT and PASETO without changing the rest of our application code.

1.  Create a new directory: `token`
2.  Inside `token`, create a new file: `maker.go`

```go
// token/maker.go
package token

import "time"

// Maker is an interface for creating and verifying tokens.
// This design allows us to easily switch between different token makers.	type Maker interface {
	// CreateToken creates a new token for a specific username and duration.
	CreateToken(username string, duration time.Duration) (string, error)

	// VerifyToken checks if the input token is valid or not.
	VerifyToken(token string) (*Payload, error)
}
```

This interface clearly defines the two essential functions our token logic will need.

---

### Step 2: Create the Token Payload

The payload contains the actual data we want to store inside the token. It's essential for identifying the user and managing the token's lifecycle.

1.  **Install the `google/uuid` package** to give each token a unique ID. This is vital for enabling features like token blocklisting if a token is ever compromised.

    ```bash
    go get github.com/google/uuid
    ```

2.  **Create the `payload.go` file** inside the `token` directory.

    ```go
    // token/payload.go
    package token

    import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
    )

    // Define token-related errors
    var (
        ErrInvalidToken = errors.New("token is invalid")
        ErrExpiredToken = errors.New("token has expired")
    )

    // Payload contains the payload data of the token.
    type Payload struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        IssuedAt  time.Time `json:"issued_at"`
        ExpiredAt time.Time `json:"expired_at"`
    }

    // NewPayload creates a new token payload for a specific username and duration.
    func NewPayload(username string, duration time.Duration) (*Payload, error) {
        tokenID, err := uuid.NewRandom()
        if err != nil {
            return nil, err
        }

        payload := &Payload{
            ID:        tokenID,
            Username:  username,
            IssuedAt:  time.Now(),
            ExpiredAt: time.Now().Add(duration),
        }
        return payload, nil
    }

    // GetExpirationTime implements the jwt.Claims interface.
    func (payload *Payload) GetExpirationTime() (*jwt.NumericDate, error) {
        return jwt.NewNumericDate(payload.ExpiredAt), nil
    }

    // GetIssuedAt implements the jwt.Claims interface.
    func (payload *Payload) GetIssuedAt() (*jwt.NumericDate, error) {
        return jwt.NewNumericDate(payload.IssuedAt), nil
    }

    // The following methods are required by the jwt.Claims interface but are not
    // needed for our specific use case, so we provide minimal implementations.

    func (payload *Payload) GetNotBefore() (*jwt.NumericDate, error) {
        return nil, nil
    }

    func (payload *Payload) GetIssuer() (string, error) {
        return "", nil
    }

    func (payload *Payload) GetSubject() (string, error) {
        return "", nil
    }

    func (payload *Payload) GetAudience() (jwt.ClaimStrings, error) {
        return nil, nil
    }
    ```

---

### Step 3: Implement the JWT Maker

Now, let's implement our `Maker` interface using JWT. We will use the modern `jwt/v5` library.

1.  **Install the `jwt/v5` package**:

    ```bash
    go get github.com/golang-jwt/jwt/v5
    ```

2.  **Create the `jwt_maker.go` file** inside the `token` directory.

    ```go
    // token/jwt_maker.go
    package token

    import (
        "errors"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
    )

    const minSecretKeySize = 32

    // JWTMaker is a JSON Web Token maker
    type JWTMaker struct {
        secretKey string
    }

    // NewJWTMaker creates a new JWTMaker
    func NewJWTMaker(secretKey string) (Maker, error) {
        if len(secretKey) < minSecretKeySize {
            return nil, fmt.Errorf("invalid key size: must be at least %d characters", minSecretKeySize)
        }
        return &JWTMaker{secretKey}, nil
    }

    // CreateToken creates a new token for a specific username and duration
    func (maker *JWTMaker) CreateToken(username string, duration time.Duration) (string, error) {
        payload, err := NewPayload(username, duration)
        if err != nil {
            return "", err
        }

        jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)
        return jwtToken.SignedString([]byte(maker.secretKey))
    }

    // VerifyToken checks if the token is valid or not
    func (maker *JWTMaker) VerifyToken(token string) (*Payload, error) {
        // This key function is crucial for security. It ensures that the token's
        // signing algorithm is what we expect (HMAC), preventing algorithm confusion attacks.
        keyFunc := func(token *jwt.Token) (interface{}, error) {
            _, ok := token.Method.(*jwt.SigningMethodHMAC)
            if !ok {
                return nil, ErrInvalidToken
            }
            return []byte(maker.secretKey), nil
        }

        jwtToken, err := jwt.ParseWithClaims(token, &Payload{}, keyFunc)
        if err != nil {
            // The jwt/v5 library automatically checks the expiration time.
            // We just need to check for the specific error it returns.
            if errors.Is(err, jwt.ErrTokenExpired) || errors.Is(err, jwt.ErrTokenNotValidYet) {
                return nil, ErrExpiredToken
            }
            return nil, ErrInvalidToken
        }

        payload, ok := jwtToken.Claims.(*Payload)
        if !ok {
            return nil, ErrInvalidToken
        }

        return payload, nil
    }
    ```

    **Important Note on JWT v5 Validation:**

    You'll notice our `Payload` struct does not have a `Valid()` method. This is a key difference in `jwt/v5` compared to older libraries.

    *   **Old Way:** You had to implement a `Valid()` method to check the expiration time yourself.
    *   **New Way (`jwt/v5`):** The library handles this automatically. By implementing the `jwt.Claims` interface (specifically `GetExpirationTime`), `jwt.ParseWithClaims` performs the time validation internally and returns `jwt.ErrTokenExpired` if the token is expired. Our code correctly checks for this specific error.

---

### Step 4: Unit Test the JWT Maker

Testing is critical, especially for security components. We need to test the happy path, expired tokens, and importantly, the `alg: "none"` attack vector.

1.  **Create `jwt_maker_test.go`** in the `token` directory.

    ```go
    // token/jwt_maker_test.go
    package token

    import (
        "testing"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ngodup/simplebank/util"
        "github.com/stretchr/testify/require"
    )

    func TestJWTMaker(t *testing.T) { /* ... */ }

    func TestExpiredJWTToken(t *testing.T) { /* ... */ }

    // This test ensures our keyFunc correctly rejects tokens signed with the "none" algorithm.
    func TestInvalidJWTTokenAlgNone(t *testing.T) {
        payload, err := NewPayload(util.RandomOwner(), time.Minute)
        require.NoError(t, err)

        // Create a token with the "none" signing method
        jwtToken := jwt.NewWithClaims(jwt.SigningMethodNone, payload)
        token, err := jwtToken.SignedString(jwt.UnsafeAllowNoneSignatureType)
        require.NoError(t, err)

        // Create a maker
        maker, err := NewJWTMaker(util.RandomString(32))
        require.NoError(t, err)

        // Verify the token. This should fail because our keyFunc rejects SigningMethodNone.
        payload, err = maker.VerifyToken(token)
        require.Error(t, err)
        require.EqualError(t, err, ErrInvalidToken.Error())
        require.Nil(t, payload)
    }
    ```
    *(Note: The full code for the other tests is in the project files.)*

---

### Step 5: Implement the PASETO Maker

Now, let's see how much simpler and safer it is to implement the same interface with PASETO.

1.  **Install the `paseto` package**:

    ```bash
    go get github.com/o1egl/paseto
    ```

2.  **Create `paseto_maker.go`** in the `token` directory.

    ```go
    // token/paseto_maker.go
    package token

    import (
        "fmt"
        "time"

        "github.com/aead/chacha20poly1305"
        "github.com/o1egl/paseto"
    )

    // PasetoMaker is a PASETO token maker
    type PasetoMaker struct {
        paseto       *paseto.V2
        symmetricKey []byte
    }

    // NewPasetoMaker creates a new PasetoMaker
    func NewPasetoMaker(symmetricKey string) (Maker, error) {
        // PASETO enforces a specific key size, preventing weak key usage.
        if len(symmetricKey) != chacha20poly1305.KeySize {
            return nil, fmt.Errorf("invalid key size: must be exactly %d characters", chacha20poly1305.KeySize)
        }

        maker := &PasetoMaker{
            paseto:       paseto.NewV2(),
            symmetricKey: []byte(symmetricKey),
        }

        return maker, nil
    }

    // CreateToken creates a new token for a specific username and duration
    func (maker *PasetoMaker) CreateToken(username string, duration time.Duration) (string, error) {
        payload, err := NewPayload(username, duration)
        if err != nil {
            return "", err
        }

        // Encrypt the payload to create the token. Simple and secure.
        return maker.paseto.Encrypt(maker.symmetricKey, payload, nil)
    }

    // VerifyToken checks if the token is valid or not
    func (maker *PasetoMaker) VerifyToken(token string) (*Payload, error) {
        payload := &Payload{}

        // Decrypt the token. The library handles cryptographic verification.
        err := maker.paseto.Decrypt(token, maker.symmetricKey, payload, nil)
        if err != nil {
            return nil, ErrInvalidToken
        }

        // After successful decryption, we must still manually check the expiration.
        if time.Now().After(payload.ExpiredAt) {
            return nil, ErrExpiredToken
        }

        return payload, nil
    }
    ```

    Notice how much cleaner this is. There's no need for a `keyFunc` because PASETO doesn't allow algorithm selection in the token itself, making algorithm confusion attacks impossible by design.

3.  **Create `paseto_maker_test.go`** to test our implementation. The tests will be very similar to the JWT tests, but we don't need a test for the `alg: "none"` attack because it's not a vulnerability in PASETO.

---

### Conclusion: JWT vs. PASETO

*   **JWT:** Powerful and flexible, but its flexibility can be a source of security vulnerabilities if not implemented carefully. Verification logic is more complex due to the need to prevent attacks like algorithm confusion.
*   **PASETO:** Secure by default. It makes safe choices for you, resulting in simpler, cleaner, and less error-prone code. For most use cases, especially when you control both the token creation and verification, PASETO is the superior choice.

By using a `Maker` interface, you can now easily switch your application from JWT to the more secure PASETO implementation by changing just one line of code in your dependency injection setup!

____________________________________________*****************************__________________________________

Lession 23. Implement login user API that returns PASETO or JWT access token in Go
-------------------------------------------------------------------------------------
### Tutorial: Implementing a Secure Login API in Go

Welcome to this lesson where we'll build a secure login API for our Simple Bank application. 
This API will allow users to authenticate using their username and password and, in return, receive an access token. We'll be using PASETO for token generation, which is a secure alternative to JWT.

#### **Step 1: Project Setup and Configuration**

Before we start coding, let's set up our environment and configuration.

1.  **Environment Variables:** We need to add two new environment variables to our `app.env` file:

    *   `TOKEN_SYMMETRIC_KEY`: This is a 32-character secret key used to sign our PASETO tokens. It's crucial that this key is kept secret and is exactly 32 characters long.
    *   `ACCESS_TOKEN_DURATION`: This defines how long our access tokens will be valid. For security reasons, we'll keep this short, for example, `15m` for 15 minutes.

    Your `app.env` file should look like this:

    ```
    DB_DRIVER=postgres
    DB_SOURCE=postgresql://postgres:mysecretpassword@localhost:5432/simple_bank?sslmode=disable
    SERVER_ADDRESS=0.0.0.0:8080
    TOKEN_SYMMETRIC_KEY=12345678901234567890123456789012
    ACCESS_TOKEN_DURATION=15m
    ```

2.  **Configuration Struct:** Now, let's update our `Config` struct in `util/config.go` to load these new variables:

    ```go
    package util

    import (
    	"time"

    	"github.com/spf13/viper"
    )

    type Config struct {
    	DBDriver            string        `mapstructure:"DB_DRIVER"`
    	DBSource            string        `mapstructure:"DB_SOURCE"`
    	ServerAddress       string        `mapstructure:"SERVER_ADDRESS"`
    	TokenSymmetricKey   string        `mapstructure:"TOKEN_SYMMETRIC_KEY"`
    	AccessTokenDuration time.Duration `mapstructure:"ACCESS_TOKEN_DURATION"`
    }

    // ... (rest of the file)
    ```

#### **Step 2: Integrating the Token Maker into the API Server**

Next, we'll integrate the token maker into our API server. This will allow us to create and verify tokens.

1.  **Update Server Struct:** In `api/server.go`, add the `token.Maker` and `util.Config` to the `Server` struct:

    ```go
    package api

    import (
        // ... other imports
        "github.com/ngodup/simplebank/token"
        "github.com/ngodup/simplebank/util"
    )

    type Server struct {
        config     util.Config
        store      db.Store
        tokenMaker token.Maker
        router     *gin.Engine
    }
    ```

2.  **Update `NewServer` Function:** Modify the `NewServer` function to create and initialize the token maker:

    ```go
    func NewServer(config util.Config, store db.Store) (*Server, error) {
        tokenMaker, err := token.NewPasetoMaker(config.TokenSymmetricKey)
        if err != nil {
            return nil, fmt.Errorf("cannot create token maker: %w", err)
        }

        server := &Server{
            config:     config,
            store:      store,
            tokenMaker: tokenMaker,
        }

        // ... (rest of the function)
    }
    ```

3.  **Update `main.go`:** We need to pass the configuration to the `NewServer` function in `main.go`:

    ```go
    func main() {
        config, err := util.LoadConfig(".")
        if err != nil {
            log.Fatal("cannot load config:", err)
        }

        // ... (database connection)

        store := db.NewStore(conn)
        server, err := api.NewServer(config, store)
        if err != nil {
            log.Fatal("cannot create server:", err)
        }

        // ... (start server)
    }
    ```

#### **Step 3: Implementing the Login API Handler**

Now for the core of our lesson: implementing the login API handler.

1.  **Request and Response Structs:** In `api/user.go`, define the request and response structs for our login API:

    ```go
    type loginUserRequest struct {
        Username string `json:"username" binding:"required,alphanum"`
        Password string `json:"password" binding:"required,min=6"`
    }

    type loginUserResponse struct {
        AccessToken string       `json:"access_token"`
        User        userResponse `json:"user"`
    }
    ```

2.  **`loginUser` Handler:** Create the `loginUser` handler function in `api/user.go`:

    ```go
    func (server *Server) loginUser(ctx *gin.Context) {
        var req loginUserRequest
        if err := ctx.ShouldBindJSON(&req); err != nil {
            ctx.JSON(http.StatusBadRequest, errorResponse(err))
            return
        }

        user, err := server.store.GetUser(ctx, req.Username)
        if err != nil {
            if err == sql.ErrNoRows {
                ctx.JSON(http.StatusNotFound, errorResponse(err))
                return
            }
            ctx.JSON(http.StatusInternalServerError, errorResponse(err))
            return
        }

        err = util.CheckPassword(req.Password, user.HashedPassword)
        if err != nil {
            ctx.JSON(http.StatusUnauthorized, errorResponse(err))
            return
        }

        accessToken, err := server.tokenMaker.CreateToken(user.Username, server.config.AccessTokenDuration)
        if err != nil {
            ctx.JSON(http.StatusInternalServerError, errorResponse(err))
            return
        }

        rsp := loginUserResponse{
            AccessToken: accessToken,
            User:        newUserResponse(user),
        }

        ctx.JSON(http.StatusOK, rsp)
    }
    ```

3.  **Refactor `userResponse`:** To avoid exposing the user's hashed password, we'll create a `newUserResponse` function that maps the `db.User` to a `userResponse` struct:

    ```go
    type userResponse struct {
        Username          string    `json:"username"`
        FullName          string    `json:"full_name"`
        Email             string    `json:"email"`
        PasswordChangedAt time.Time `json:"password_changed_at"`
        CreatedAt         time.Time `json:"created_at"`
    }

    func newUserResponse(user db.User) userResponse {
        return userResponse{
            Username:          user.Username,
            FullName:          user.FullName,
            Email:             user.Email,
            PasswordChangedAt: user.PasswordChangeAt,
            CreatedAt:         user.CreatedAt,
        }
    }
    ```

#### **Step 4: Routing and Testing**

Finally, let's add the new route to our server and update our tests.

1.  **Add Route:** In `api/server.go`, add the login route to the `setupRouter` function:

    ```go
    func (server *Server) setupRouter() {
        router := gin.Default()
        router.POST("/users", server.createUser)
        router.POST("/users/login", server.loginUser)

        // ... (other routes)

        server.router = router
    }
    ```

2.  **Update Tests:** We need to update our tests to use the new `NewServer` function that takes a `config` object. In `api/main_test.go`, create a `newTestServer` helper function:

    ```go
    func newTestServer(t *testing.T, store db.Store) *Server {
        config := util.Config{
            TokenSymmetricKey:   util.RandomString(32),
            AccessTokenDuration: time.Minute,
        }
        server, err := NewServer(config, store)
        require.NoError(t, err)

        return server
    }
    ```

    Now, in your test files (`account_test.go`, `user_test.go`, etc.), replace `api.NewServer(store)` with `newTestServer(t, store)`.

Congratulations! You have successfully implemented a secure login API in Go. You can now run the server and test the login functionality using a tool like Postman.


____________________________________________*****************************__________________________________
Lession 24. Implement authentication middleware and authorization rules in Golang using Gin
--------------------------------------------------------------------------------------------




____________________________________________*****************************__________________________________
____________________________________________*****************************__________________________________